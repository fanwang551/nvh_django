
需求：当前任务是否闭环（is_closed = 1）的计算逻辑发生变化，帮我修改前后端实现该需求，
当前是否闭环判断逻辑在`backend/apps/nvh_task/services.py`中16-52行:
```'def refresh_main_closed(main: MainRecord) -> MainRecord:
    """
    刷新单个 MainRecord 的闭环状态
    闭环条件：
    - entry_exit 存在且 status == SUBMITTED
    - test_info 存在且 status == SUBMITTED
    - doc_approval 存在且 status == SUBMITTED
    """
    entry_exit_ok = (
        main.entry_exit is not None
        and not main.entry_exit.is_deleted
        and main.entry_exit.status == STATUS_SUBMITTED
    )

    test_info_ok = False
    try:
        test_info = main.test_info
        if test_info and not test_info.is_deleted:
            test_info_ok = test_info.status == STATUS_SUBMITTED
    except TestInfo.DoesNotExist:
        pass

    doc_approval_ok = False
    try:
        doc_approval = main.doc_approval
        if doc_approval and not doc_approval.is_deleted:
            doc_approval_ok = doc_approval.status == STATUS_SUBMITTED
    except DocApproval.DoesNotExist:
        pass

    is_closed = entry_exit_ok and test_info_ok and doc_approval_ok

    main.is_closed = is_closed
    main.closure_checked_at = timezone.now()
    main.save(update_fields=['is_closed', 'closure_checked_at'])

    return main
   ```
你可以修改`apps/nvh_task/models.py`中模型，`backend/apps/nvh_task/services.py`判断逻辑
视图代码：`backend/apps/nvh_task/views.py` 序列化器`backend/apps/nvh_task/serializers.py`
方案如下：
## 方案概述
通过在 `MainRecord` 上增加两个字段：`task_scenario`（任务场景）与 `doc_requirement`（是否要求技术资料），将闭环判断从“固定三表全提交”改为“按场景决定哪些表单需要提交”。`is_closed` 仍为**存储型布尔值**（0/1），闭环动作发生时按新规则校验并置为 1；闭环仅代表流程结束，不限制表单是否存在或是否为空。

---

## 1) 字段/状态依赖（字段设计与语义）

### MainRecord 新增字段
1. **`task_scenario`**（枚举）
   - `NORMAL`（默认）
   - `CANCEL_WITH_SAMPLE`
   - `CANCEL_NO_SAMPLE`
   **语义**：决定 EntryExit / TestInfo 是否为闭环必需项。

2. **`doc_requirement`**（布尔值）
   - `1`：DocApproval 为闭环必需项
   - `0`：DocApproval 不参与闭环（可填可不填、存在与否不影响闭环）
   **语义**：明确 DocApproval 的“是否要求”属于任务级决策，避免用 DocApproval 自身状态（因为它可能不存在/软删）。
添加的字段不要设置为choice
### 表单状态判定口径（用于闭环校验）
对被要求的表单，满足条件统一定义为：
- **记录存在**
- `is_deleted = false`
- `status = SUBMITTED`



---

## 2) 四种场景闭环规则（规则表）

记号：
- `EE_OK`：MainRecord 指向的 EntryExit 满足提交（存在 + 未删 + SUBMITTED）
- `TI_OK`：TestInfo 满足提交（存在 + 未删 + SUBMITTED）
- `DA_OK`：DocApproval 满足提交（存在 + 未删 + SUBMITTED）

| 场景 | task_scenario | doc_requirement | 闭环必需项 | 闭环条件 |
|---|---|---:|---|---|
| 1 正常任务（不需要技术资料） | NORMAL | 0 | EntryExit、TestInfo | `EE_OK && TI_OK` |
| 1 正常任务（需要技术资料） | NORMAL | 1 | EntryExit、TestInfo、DocApproval | `EE_OK && TI_OK && DA_OK` |
| 2 取消且有样品 | CANCEL_WITH_SAMPLE | 0/1（不影响） | EntryExit | `EE_OK` |
| 3 取消且无样品 | CANCEL_NO_SAMPLE | 0/1（不影响） | 无 | 直接允许闭环（`true`） |
| 4 DocApproval 永远可选的体现 | 全部场景 | doc_requirement=0 | DocApproval 不阻塞 | `DA` 相关完全忽略 |

> 说明：“取消类场景只看 EntryExit 或直接闭环”，因此 `doc_requirement` 在取消类场景下不生效（最简单）。

---


## 3) 前后端交互要点

前端/交互：
- store地址：`frontend/src/store/NVHtask.js`
- 在`frontend/src/views/business/TaskMainList.vue`的“添加主记录”弹窗表单中'备注‘前添加'任务状态'字段默认值为NORMAL；
下拉框为：正常、取消有样品、取消无样品三个选项，分别对应NORMAL、CANCEL_WITH_SAMPLE、 CANCEL_NO_SAMPLE；
- 在`frontend/src/views/business/components/tabs/DocApprovalTab.vue`中添加是否需要填写DocApproval表单交互逻辑，选择是则设置doc_requirement=1，否则设置doc_requirement=0
- MainRecord 创建时 `task_scenario` 默认 `NORMAL` 校验时该字段为必填
- 正常任务时允许用户选择是否需要技术资料（写 `doc_requirement`）
- 取消场景仍可提交任意表单，不影响闭环（符合你确认）

后端/闭环动作：
- 闭环按钮（或闭环接口）触发时，按上表规则校验必需项：
  - 不满足 → `is_closed=0`
  - 满足 → 将 `is_closed=1`
- 因为 `is_closed` 是存储值，规则变化不会自动改历史记录.




下面是一份可直接复制给 **Cursor** 的提示词（Prompt）。它会引导 Cursor 在你的代码库中完成后端+前端的改造，并严格按你给的“方案概述/规则表/交互要点”实现。

-
# 目标
“当前任务是否闭环（is_closed=1）的计算逻辑发生变化”：从原先固定判断 EntryExit/TestInfo/DocApproval 三表都 SUBMITTED，改为按 MainRecord 的场景字段与是否要求技术资料字段决定必需项。

is_closed 仍然是**存储型布尔值**，只在“闭环动作/闭环接口”触发时按新规则校验并写入（满足置 1，不满足置 0）。

---

# 后端改造要求

## 1) 模型变更（不执行迁移）
文件：`backend/apps/nvh_task/models.py`

在 `MainRecord` 模型上新增两个字段（不要设置为 choices）：

1. `task_scenario`（字符串或等价字段类型，建议 CharField）
   - 必填（创建时必须有值）
   - 默认值为 `"NORMAL"`
   - 允许值（不做 choices，逻辑上使用以下三种）：
     - `"NORMAL"`
     - `"CANCEL_WITH_SAMPLE"`
     - `"CANCEL_NO_SAMPLE"`

2. `doc_requirement`（布尔，表达 0/1）
   - 默认 0（false）
   - 语义：1 表示 DocApproval 为闭环必需项；0 表示 DocApproval 完全不影响闭环

不要执行迁移命令我自己执行

---

## 2) 闭环判断逻辑变更（服务层）
文件：`backend/apps/nvh_task/services.py`

当前闭环逻辑在 `refresh_main_closed(main: MainRecord)`（原 16-52 行）按固定三表 SUBMITTED 判断。请重写为按下面规则：

### 表单 OK 口径（用于“被要求时”的校验）
对被要求的表单，满足条件统一定义为：
- 记录存在
- `is_deleted = false`
- `status = SUBMITTED`

### 场景闭环规则（必须严格实现）
记号：
- EE_OK：EntryExit 满足 OK
- TI_OK：TestInfo 满足 OK
- DA_OK：DocApproval 满足 OK

规则表：

1) 正常任务（NORMAL）
- 若 `doc_requirement=0`：闭环条件 `EE_OK && TI_OK`
- 若 `doc_requirement=1`：闭环条件 `EE_OK && TI_OK && DA_OK`

2) 取消且有样品（CANCEL_WITH_SAMPLE）
- `doc_requirement` 不生效
- 闭环条件：`EE_OK`

3) 取消且无样品（CANCEL_NO_SAMPLE）
- `doc_requirement` 不生效
- 闭环条件：直接允许闭环 `true`（无任何必需项）

4) doc_requirement=0 的体现
- 任意场景 doc_requirement=0 时，DocApproval 不阻塞闭环（完全忽略 DA）

注意：取消场景下仍允许用户提交任意表单，但不影响闭环判断（按上面规则即可）。

### 写库行为保持
仍然：
- 计算 is_closed
- 写 `main.is_closed = is_closed`
- 更新 `closure_checked_at = timezone.now()`
- `save(update_fields=['is_closed','closure_checked_at'])`

---

## 3) API/序列化器/视图联动
文件：
- `backend/apps/nvh_task/serializers.py`
- `backend/apps/nvh_task/views.py`

要求：
1. MainRecord 创建与更新时，序列化器需要支持读写 `task_scenario`、`doc_requirement`
2. MainRecord 创建时：
   - `task_scenario` 必填（即便模型默认 NORMAL，但是不需要 serializer 校验，前端校验必填即可）
   - 默认 NORMAL
3. 所有返回 MainRecord 的列表/详情接口应返回这两个新字段，以供前端展示/控制交互。
4. 闭环接口/闭环按钮对应的后端逻辑必须调用 `refresh_main_closed` 使用新规则。

---

# 前端改造要求

前端涉及文件：
- `frontend/src/store/NVHtask.js`
- `frontend/src/views/business/TaskMainList.vue`
- `frontend/src/views/business/components/tabs/DocApprovalTab.vue`

## 1) store：MainRecord 创建/更新 payload 增加字段
- 创建 MainRecord 时 payload 必须带上：
  - `task_scenario`（默认 "NORMAL"）
  - `doc_requirement`（默认 0）
- 若 store 中有 MainRecord 的 edit/save，也要确保这两个字段能被保存/更新。

## 2) TaskMainList.vue：添加主记录弹窗增加“任务状态”字段
在“添加主记录”弹窗表单中，在“备注”字段之前插入字段：
- label：任务状态
- 默认值：NORMAL
- 下拉选项：
  - 正常 → NORMAL
  - 取消有样品 → CANCEL_WITH_SAMPLE
  - 取消无样品 → CANCEL_NO_SAMPLE

创建时必须把该值提交给后端。

## 3) DocApprovalTab.vue：加入 doc_requirement 交互逻辑
在 DocApproval 表单页签（DocApprovalTab）增加“是否需要填写技术资料/DocApproval”之类的交互（以现有 UI 风格为准）：
- 选择“是” → 设置 `doc_requirement=1`
- 选择“否” → 设置 `doc_requirement=0`

要求：
- 该选择应写回 MainRecord（调用已有更新接口/或 store action）
- 当 `doc_requirement=0` 时，DocApproval 即便未提交也不影响闭环（后端已保证），前端不必额外拦截闭环，但可以在 UI 上提示“可选”。

## 4) 取消场景说明（前端不限制）
当 task_scenario 为取消类场景时：
- 仍允许进入任何 tab 提交任意表单
- 但不需要强制用户填写 DocApproval / TestInfo（前端不要做强校验阻止）

---

# 代码实现注意点
1. 不要给 `task_scenario` 加 choices（需求明确）
2. 不用管已有记录数据目前在开发阶段，且不要执行迁移命令
3. 仅在“闭环动作发生时”刷新 is_closed：不要引入自动定时重算历史记录的机制
4. 修改后跑通：创建 MainRecord、切换任务状态、设置 doc_requirement、提交各表单后闭环状态符合规则表

---

# 交付物/验收点（你改完后自查）
1. 不用执行迁移，我自己执行
2. MainRecord API 返回含 `task_scenario`、`doc_requirement`
3. 创建主记录时前端能选任务状态并提交成功
4. DocApprovalTab 能切换 doc_requirement 并保存到后端
5. 闭环逻辑符合：
   - NORMAL + doc_requirement=0：只需 EntryExit+TestInfo 提交即可闭环
   - NORMAL + doc_requirement=1：三表都提交才闭环
   - CANCEL_WITH_SAMPLE：只需 EntryExit 提交即可闭环
   - CANCEL_NO_SAMPLE：无需任何表单也可闭环
6. doc_requirement 在取消场景不影响闭环


