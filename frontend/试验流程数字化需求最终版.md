

你要在现有 Django + Vue 项目中实现“试验任务管理（NVH Task）”模块。要求：**只改代码**，但代码必须完整、可读、可落地。不需要编写自动化测试。。

## 0. 项目已知信息
1. 前端 UI：**Element Plus**。
2. 前端 API 调用封装目录：`frontend/src/api`（已有请求封装，参考项目现有案例写新的 api 文件即可）。
3. 安排人员白名单（前端权限控制用）：`['w1234','w1235']`，判断方式：`username in whitelist`。
4. 列表筛选字段必须包含：**车型/VIN/加入预警系统/合同号/时间范围/任务提出人/测试人员/是否闭环**。
5. 软删除：默认查询只返回未删除数据；destroy 必须走 soft_delete，不得物理删除。
6. 闭环字段 `MainRecord.is_closed`：**只能在 submit/unsubmit/更换(解绑) entry_exit 时刷新一次并落库**；列表页只读此字段，不实时计算。
7. status 仅使用字符串常量：`DRAFT|SUBMITTED`（后端不加 choices）。
- settings中media：MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
---

# 1. 后端（Django + DRF）

## 1.1 新建 app
在 `backend/apps/` 下新增 `nvh_task` app，文件齐全：
- `backend/apps/nvh_task/apps.py`
- `backend/apps/nvh_task/models.py`
- `backend/apps/nvh_task/serializers.py`
- `backend/apps/nvh_task/services.py`
- `backend/apps/nvh_task/views.py`
- `backend/apps/nvh_task/urls.py`
并完成：
- 将 `nvh_task` 加入 `INSTALLED_APPS`
- 将路由挂到项目总路由（例如 `/api/nvh-task/` 前缀）


---

## 1.2 models.py（必须包含：软删除基类 + 全量模型代码）
### 1) 软删除基类（直接放 models.py 顶部）
> 必须实现且所有业务模型继承 SoftDeleteModel

```python
from django.db import models, transaction
from django.utils import timezone


class SoftDeleteQuerySet(models.QuerySet):
    def delete(self):
        """QuerySet 批量删除时，默认做软删除"""
        return super().update(is_deleted=True, deleted_at=timezone.now())

    def hard_delete(self):
        """物理删除（一般不用）"""
        return super().delete()

    def alive(self):
        return self.filter(is_deleted=False)

    def dead(self):
        return self.filter(is_deleted=True)


class SoftDeleteManager(models.Manager):
    """默认只返回未删除数据"""
    def get_queryset(self):
        return SoftDeleteQuerySet(self.model, using=self._db).filter(is_deleted=False)


class SoftDeleteModel(models.Model):
    is_deleted = models.BooleanField(default=False, db_index=True)
    deleted_at = models.DateTimeField(null=True, blank=True)

    objects = SoftDeleteManager()     # 默认过滤 is_deleted=False
    all_objects = models.Manager()    # 可查询全部（含已删除）

    class Meta:
        abstract = True

    def delete(self, using=None, keep_parents=False):
        """兜底：任何地方调用 instance.delete() 也走软删除"""
        return self.soft_delete(using=using, keep_parents=keep_parents)

    def soft_delete(self, using=None, keep_parents=False):
        """实例软删除"""
        if self.is_deleted:
            return
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save(update_fields=["is_deleted", "deleted_at"])

    def restore(self):
        """恢复（如将来需要）"""
        if not self.is_deleted:
            return
        self.is_deleted = False
        self.deleted_at = None
        self.save(update_fields=["is_deleted", "deleted_at"])

    def hard_delete(self, using=None, keep_parents=False):
        """物理删除（一般不用）"""
        return super().delete(using=using, keep_parents=keep_parents)
```

### 2) 状态常量（models.py 顶部）
```python
STATUS_DRAFT = "DRAFT"
STATUS_SUBMITTED = "SUBMITTED"
```

### 3) 全量业务模型（关系不可改变；ImageField 按要求实现）


```python
from django.core.exceptions import ValidationError


class EntryExit(SoftDeleteModel):
    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    enter_time = models.DateTimeField(null=True, blank=True, verbose_name="进入时间")
    purpose = models.CharField(max_length=100, null=True, blank=True, default="测试", verbose_name="用途")

    dispose_type = models.CharField(max_length=20, null=True, blank=True, verbose_name="报废/归还类型")
    disposer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="报废/归还人姓名")
    dispose_time = models.DateTimeField(null=True, blank=True, verbose_name="报废/归还时间")
    return_receiver = models.CharField(max_length=100, null=True, blank=True, verbose_name="归还接受人")

    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")
    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "车辆及零件进出登记"
        verbose_name_plural = "车辆及零件进出登记"

    def __str__(self):
        return f"EntryExit#{self.id}"

    def active_mainrecord_count(self) -> int:
        # related manager 使用 MainRecord.objects（默认过滤 is_deleted=False）
        return self.main_records.count()

    def soft_delete(self, using=None, keep_parents=False):
        if self.active_mainrecord_count() > 1:
            raise ValidationError("该进出登记被多条任务引用，不能删除。请先解绑或仅保留一条引用。")
        return super().soft_delete(using=using, keep_parents=keep_parents)


class MainRecord(SoftDeleteModel):
    model = models.CharField(max_length=100, verbose_name="车型")
    vin_or_part_no = models.CharField(max_length=100, db_index=True, verbose_name="VIN码/零件编号")
    test_name = models.CharField(max_length=200, verbose_name="试验名称")

    warning_system_status = models.CharField(max_length=20, verbose_name="加入预警系统状态")

    requester_name = models.CharField(max_length=100, verbose_name="任务提出人")
    schedule_start = models.DateTimeField(db_index=True, verbose_name="试验安排开始时间")
    schedule_end = models.DateTimeField(null=True, blank=True, verbose_name="试验安排结束时间")
    schedule_remark = models.CharField(max_length=500, null=True, blank=True, verbose_name="试验安排时间备注")
    test_location = models.CharField(max_length=200, null=True, blank=True, verbose_name="试验地点")

    tester_name = models.CharField(max_length=100, verbose_name="测试人员")
    contract_no = models.CharField(max_length=100, null=True, blank=True, db_index=True, verbose_name="合同编号")
    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")

    entry_exit = models.ForeignKey(
        "EntryExit",
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="main_records",
        verbose_name="关联进出登记",
    )

    is_closed = models.BooleanField(default=False, db_index=True, verbose_name="是否闭环")
    closure_checked_at = models.DateTimeField(null=True, blank=True, verbose_name="闭环判断更新时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "任务主记录"
        verbose_name_plural = "任务主记录"

    def __str__(self):
        return f"MainRecord#{self.id} {self.vin_or_part_no} {self.test_name}"

    def soft_delete(self, using=None, keep_parents=False):
        """
        主记录软删除策略：
        - 不动 EntryExit（共享）
        - 同步软删除 OneToOne：TestInfo、DocApproval
        """
        with transaction.atomic():
            if hasattr(self, "test_info") and self.test_info and not self.test_info.is_deleted:
                self.test_info.soft_delete()
            if hasattr(self, "doc_approval") and self.doc_approval and not self.doc_approval.is_deleted:
                self.doc_approval.soft_delete()
            return super().soft_delete(using=using, keep_parents=keep_parents)


class TestInfo(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="test_info",
        verbose_name="关联主任务",
    )

    contact_phone = models.CharField(max_length=50, verbose_name="联系方式")
    nvh_lab_mgmt_no = models.CharField(max_length=100, db_index=True, verbose_name="NVH试验室管理号")

    sample_type = models.CharField(max_length=20, verbose_name="样品名称")
    rd_stage = models.CharField(max_length=20, verbose_name="研发阶段")
    delivery_dept = models.CharField(max_length=200, verbose_name="送件部门")

    report_required = models.CharField(max_length=20, verbose_name="是否出具试验/不确定度报告")
    report_no = models.CharField(max_length=100, default="/", verbose_name="报告编号")

    include_teardown_record = models.CharField(max_length=20, default="否", verbose_name="是否包含拆装记录表")
    include_process_record = models.CharField(max_length=20, default="否", verbose_name="是否包含试验过程记录表")

    teardown_attachment_url = models.ImageField(
        upload_to='nvh_task/teardown_record/',
        null=True, blank=True,
        verbose_name="拆装记录表附件(图片)"
    )

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "试验信息登记"
        verbose_name_plural = "试验信息登记"

    def __str__(self):
        return f"TestInfo(main_id={self.main_id})"

    def soft_delete(self, using=None, keep_parents=False):
        from .models import TestProcessAttachment  # 防循环时可挪到文件底部再引用
        with transaction.atomic():
            TestProcessAttachment.all_objects.filter(
                test_info_id=self.id, is_deleted=False
            ).update(is_deleted=True, deleted_at=timezone.now())
            return super().soft_delete(using=using, keep_parents=keep_parents)


class TestProcessAttachment(SoftDeleteModel):
    test_info = models.ForeignKey(
        "TestInfo",
        on_delete=models.CASCADE,
        related_name="process_attachments",
        verbose_name="关联试验信息",
    )
    record_name = models.CharField(max_length=200, verbose_name="过程记录表名")

    file_url = models.ImageField(
        upload_to='nvh_task/nvh_test_process/',
        verbose_name="图片(过程记录附件)"
    )

    sort_no = models.PositiveIntegerField(default=0, verbose_name="排序号")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        verbose_name = "试验过程记录附件"
        verbose_name_plural = "试验过程记录附件"


class TestProcessList(SoftDeleteModel):
    test_process_name = models.CharField(max_length=200, verbose_name="过程记录表名")

    class Meta:
        verbose_name = "试验过程记录表清单"
        verbose_name_plural = "试验过程记录表清单"


class DocApproval(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="doc_approval",
        verbose_name="关联主任务",
    )

    doc_name = models.CharField(max_length=200, verbose_name="名称")
    doc_no = models.CharField(max_length=100, null=True, blank=True, verbose_name="编号")
    quantity = models.PositiveIntegerField(null=True, blank=True, verbose_name="数量")

    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    issuer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="发放人")
    approver_name = models.CharField(max_length=100, default="admin", verbose_name="批准人")
    issue_date = models.DateField(verbose_name="发放日期")

    file_url = models.ImageField(
        upload_to='nvh_task_approval',
        null=True, blank=True,
        verbose_name="文件(图片)"
    )

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "技术资料发放批准单"
        verbose_name_plural = "技术资料发放批准单"
```

---

## 1.3 serializers.py（“模型是 ImageField”）
- 上传文件，数据库对应字段只会保存相对路径
-（相对 MEDIA_ROOT）例如`/nvh_task/nvh_task_approval/test.jpg`
- 已知settings中media配置：MEDIA_URL = '/media/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

同时 serializer 需要：
- EntryExit 额外返回 `active_mainrecord_count`（用于前端显示“共用 X 条任务”）
- MainRecord 返回 entry_exit/test_info/doc_approval 的状态摘要字段（可选但建议）
- 保证分页列表可用

---

## 1.4 services.py（必须封装：提交/撤回/闭环刷新/校验）
必须实现并在 views 中调用，避免把业务写散。

### 闭环刷新（严格规则）
```
is_closed =
    (entry_exit存在且SUBMITTED)
AND (test_info存在且SUBMITTED)
AND (doc_approval存在且SUBMITTED)
```

刷新触发点（只允许这些）：
- submit 成功
- unsubmit 成功
- MainRecord PATCH 更换/解绑 entry_exit

EntryExit 共享刷新（必须实现）：
- EntryExit submit/unsubmit 时刷新其所有引用 main_records

服务层建议接口：
```python
def refresh_main_closed(main: MainRecord) -> MainRecord: ...
def refresh_mains_closed_by_entry_exit(entry_exit: EntryExit) -> int: ...
def submit_entry_exit(entry_exit: EntryExit) -> EntryExit: ...
def unsubmit_entry_exit(entry_exit: EntryExit) -> EntryExit: ...
def submit_test_info(test_info: TestInfo) -> TestInfo: ...
def unsubmit_test_info(test_info: TestInfo) -> TestInfo: ...
def submit_doc_approval(doc: DocApproval) -> DocApproval: ...
def unsubmit_doc_approval(doc: DocApproval) -> DocApproval: ...
```

### 提交校验（必须后端兜底）
- TestInfo submit 校验：
  1) `include_teardown_record=="是"` → `teardown_attachment_url` 必须有
  2) `include_process_record=="是"` → 至少 1 条未软删 `TestProcessAttachment`
  3) `report_required=="否"` → `report_no` 必须为 `/`（否则 400）
- DocApproval submit 校验：`file_url` 必须有
- EntryExit submit 校验：实现“关键字段最小校验”（自行选择必填字段并写注释说明），否则 400

---



### 1) destroy 必须软删
MainRecordViewSet destroy 必须：
```python
obj.soft_delete()
return 204
```

EntryExitViewSet destroy 必须：
- 调用 `obj.soft_delete()`
- 引用>1 时捕获 Django ValidationError，转 DRF 400

### 2) OneToOne 子表 get_or_create
- `GET /api/nvh-task/main-records/{id}/test-info/`：不存在则创建 DRAFT 返回
- `GET /api/nvh-task/main-records/{id}/doc-approval/`：不存在则创建 DRAFT 返回

### 3) submit/unsubmit
- `POST /api/nvh-task/entry-exits/{id}/submit`
- `POST /api/nvh-task/entry-exits/{id}/unsubmit`
- `POST /api/nvh-task/test-infos/{id}/submit`
- `POST /api/nvh-task/test-infos/{id}/unsubmit`
- `POST /api/nvh-task/doc-approvals/{id}/submit`
- `POST /api/nvh-task/doc-approvals/{id}/unsubmit`

提交/撤回成功后：必须调用闭环刷新（EntryExit 需要刷新所有引用主任务）。

### 4) MainRecord 更换/解绑 entry_exit 触发闭环刷新
当 `PATCH main-records/{id}/` 中 `entry_exit_id` 变化（含设为 null）：
- 更新 main.entry_exit
- 调用 `refresh_main_closed(main)`
- 返回更新后的 main

---

# 2. 前端（Vue + Element Plus + Pinia）

## 2.1 页面文件（必须新增）
在 `frontend/src/views/business/` 新增：
- `TaskMainList.vue`（主列表页：筛选+分页+is_closed显示+行内编辑）
- `EntryExitForm.vue`（抽屉：新建/选择已有、显示共用数量、submit/unsubmit）
- `TestInfoForm.vue`（抽屉：含过程附件列表管理、submit/unsubmit、闭环提示条）
- `DocApprovalForm.vue`（抽屉：含 file_url、submit/unsubmit、闭环提示条）

## 2.2 Pinia Store（必须新增）
在 `frontend/src/store/` 新增 `NVHtask.js`（或同等命名）导出 `useTaskStore`，统一管理：
- 列表查询、分页、筛选（VIN/合同号/闭环/时间范围/车型/加入预警系统）
- 行内编辑（只有安排人员 username in `['w1234','w1235']` 可编辑）
- 三表单：get_or_create、保存草稿、提交/撤回
- 闭环提示条数据（仅提示，不用于列表闭环计算）

并且：从 `frontend/src/store/index.js` 获取 `username/fullname`，保存到 task store（用于默认填充 issuer_name/disposer_name 等）。

## 2.3 API 文件（必须放 frontend/src/api）
在 `frontend/src/api/` 新增（或合并到现有模块 API 文件中）：
- `nvh_task.js`（建议）：封装 main-records / entry-exits / test-infos / doc-approvals / attachments 的请求函数
请求写法完全参考项目现有案例（不要自创 axios 实例，实际封装路径`frontend/src/utils/request.js`）。

## 2.4 入口挂载（必须可进入）
- 在 `frontend/src/views/BusinessCenter.vue` 添加入口（卡片/按钮）进入任务管理页
- 在 `frontend/src/components/layout/MainLayout.vue` 添加菜单项/标签，能进入 BusinessCenter 或直接进入 TaskMainList（按现有导航结构适配）
下面是在你现有草图基础上，做了**信息架构更清晰、闭环体验更强、共享对象（进出登记）更不易出错**的一版前端设计说明（可直接给 UI/前端实现）。我尽量保持你原有结构，同时补足关键交互、状态、校验与权限边界。

---

下面是对你原「UI 设计（优化版：结构 + 关键交互 + 状态规范）」的**完整改写版**：在**不丢失原有页面内容与交互细节**的前提下，强制落地你要求的方案——**“一个抽屉 + 三个页签（Tabs）承载三张表单”**，不再在三个页面之间跳转，也不再是三个独立抽屉入口。

---

## 3、UI 设计（最终版：列表 + 统一抽屉 Tabs + 闭环一致体验）

### 3.1 主界面：试验任务管理（主表列表页）
**目标**：替代 Excel 目录表；任务排期与闭环状态一屏可见；三类表单入口统一到**同一个抽屉**；安排人员可在列表高效维护排程；试验人员在抽屉内一次性补齐缺项完成闭环。

#### 3.1.1 页面布局
- 页面标题：**试验任务管理**
- 页面结构：**筛选区 + 主列表表格 + 统一详情抽屉（Tabs 表单容器）**
- 所有时间列只显示：**YYYY-MM-DD**
- 页面级布局建议：
  - 顶部：标题 + 右侧主按钮（新增主记录，仅安排人员可见）
  - 中部：筛选区
  - 下部：列表表格（含分页）
  - 右侧：详情抽屉（点击某行“填写/查看表单”打开）

#### 3.1.2 筛选区（支持快速检索与组合筛选）
推荐控件与交互（尽量做到“输一次、筛多次”）：

- 车型（下拉 + 模糊搜索）
- VIN/零件编号（输入搜索，支持粘贴）
- 试验名称（输入搜索）
- 测试人员（输入搜索，支持多选）
- 排期日期（开始/结束范围）
- 闭环状态（全部 / 未闭环 / 已闭环）
- 预警状态（多选：是、无需、已申请、未申请、待申请）
- 任务提出人 / 合同编号（放入“更多筛选”折叠区，避免拥挤）

按钮：
- [查询] [重置]
- 右侧主操作：[新增主记录]（仅安排人员可见）

体验建议：
- 筛选条件变更后可“回车触发查询”
- 重置后自动刷新列表
- 筛选区支持“展开/收起更多筛选”

#### 3.1.3 列表表格（主表列表 + 关键状态一眼可见）
目标：用户不用点进详情就能知道闭环进度/缺什么大类。

表格列建议（支持列配置：一个“展开/列管理”按钮控制显示字段；默认隐藏合同编号、派生字段、备注等长字段；表格太长可左右滚动）：

- 闭环状态（Badge）：已闭环 / 未闭环  
- 预警
- 车型
- VIN/零件编号（支持一键复制）
- 试验名称
- 测试人员
- 任务提出人
- 排期（开始时间 ~ 结束时间，合并显示）
- 地点
- 合同编号（默认隐藏）
- 派生字段（默认隐藏）：
  - 是否拆装（来自 `TestInfo.include_teardown_record`，无 TestInfo 显示 `--`）
  - 是否过程（来自 `TestInfo.include_process_record`，无 TestInfo 显示 `--`）
- 备注（默认隐藏，长文本折叠）
- 操作（按钮组）

派生字段数据获取：
- 列表接口通过 `select_related('test_info')` 获取，不在前端做闭环重复计算

#### 3.1.4 行内编辑（仅安排人员）
- 可编辑字段仅限排程相关：**排期（开始/结束）、测试人员、地点、备注**等
- 试验人员视角：列表只读，但可以进入抽屉补齐资料

行内编辑交互建议：
- 单元格点击进入编辑态（日期范围/下拉/输入）
- 失焦自动保存（或显式“保存/取消”，二选一；建议失焦保存+撤销能力更强）
- 保存成功 Toast
- 保存失败：回滚到旧值并提示原因

#### 3.1.5 操作列（统一入口：打开“一个抽屉 + 三个 Tab”）
为了避免在三个入口之间跳来跳去，操作列统一为：

- [填写/查看表单]（主入口，所有角色可见）
  - 点击后：打开**右侧统一抽屉**（宽度建议 60% 或 720~960px 自适应）
  - 抽屉内包含 Tabs：进出登记 / 试验信息 / 技术资料
- [查看闭环原因]（可选：若保留则点击等价于打开抽屉并定位缺项；不必额外做第二个抽屉）
  - 仅当未闭环时显示
  - 点击后：打开抽屉并自动定位到第一个缺项（见闭环提示条规则）
- [删除]（仅安排人员可见，二次确认）

强烈建议：
- 列表点击“填写/查看表单”默认抽屉打开（不跳页面）

---

## 3.2 统一抽屉表单容器：Tabs 模式（必须使用）
**目标**：用户打开一次抽屉就能看全三表单状态，并顺着闭环提示条把缺项补齐；避免多页面跳转丢上下文。

### 3.2.1 抽屉结构
抽屉标题区（Header）：
- 标题：`{车型} / {VIN/零件编号} / {试验名称}`
- 右侧状态：
  - 闭环状态 Badge：已闭环 / 未闭环
  - 补充信息：显示排期、测试人员（便于核对）

抽屉内容区（Body）：
- 顶部固定（sticky）：**闭环提示条（3.3）**
- 下方：Tabs（页签）：
  - Tab1：进出登记（Entry/Exit）
  - Tab2：试验信息（TestInfo）
  - Tab3：技术资料（DocApproval）

抽屉底部（Footer）：
- 不做“全局统一提交”按钮（因为三表单提交规则不同、权限不同）
- 建议每个 Tab 内各自提供 [保存草稿]/[提交]/[撤回]，抽屉底部只提供：
  - [关闭]（或 X）
  - 可选：[刷新状态]（调试/保险用）

### 3.2.2 Tab 默认打开规则（减少用户判断成本）
- 抽屉打开时默认定位 Tab：
  1) 若未闭环：自动跳转到**闭环提示条列出的第一个缺项所属 Tab**
  2) 若已闭环：默认进入“试验信息”Tab（或记住用户上次打开的 Tab）
- Tab 切换时：
  - 如该 Tab 首次进入才拉取数据（lazy load），避免一次性请求过多
  - 切换时不丢失当前 Tab 未保存输入（本地状态暂存；关闭抽屉时提示未保存）

### 3.2.3 Tab 顶部状态提示（建议）
在每个 Tab 标题上显示小状态：
- 进出登记：未提交/已提交
- 试验信息：未提交/已提交（并可显示“过程附件 0/≥1”等小提示）
- 技术资料：未提交/已提交（文件缺失/已上传）

---

## 3.3 全局核心：闭环提示条（跨三个 Tab 一致）
**目标**：让试验人员无需问人/翻 Excel：打开抽屉就知道“还缺什么、怎么补、在哪补”。

### 3.3.1 展示位置与内容
- 位置：抽屉内容顶部 sticky（Tab 切换时始终可见）
- 展示内容：三个模块完成情况 + 缺项摘要 + 一键定位
- 推荐样式：Stepper / Status Card / 三列状态卡 + 缺项列表

示例结构（建议）：
- 进出登记：未提交 / 已提交
- 试验信息：未提交 / 已提交
  - 拆装记录：不需要 / 附件缺失 / 齐全
  - 过程记录：不需要 / 附件缺失（0/至少1）/ 齐全
- 技术资料：未提交 / 已提交（文件缺失/已上传）

**未闭环原因（可点击项）**：
- 缺少：试验过程记录表图片（至少 1 张）
- 缺少：技术资料发放批准单文件
- 缺少：进出登记未提交
……

### 3.3.2 一键定位（减少用户找字段）
交互规则：
- 点击某条缺项 → 自动切换到对应 Tab + 自动滚动到对应区域 + 对字段/附件组件做短暂高亮
- 如果缺项属于“另一个 Tab”：
  - 点击缺项时，自动切换 Tab（例如：缺“技术资料文件”→直接切到“技术资料”Tab）
- 定位粒度：
  - 能定位到“表级”（例如“闭环进出登记表”）
  

### 3.3.3 共享对象提示（EntryExit 共用）
当 EntryExit 被多个任务共用时，在闭环提示条或抽屉标题旁显示：
- “该进出登记已被 **X** 个任务共用（展开）”
- 展开列出：任务名称 / VIN / 排期 / 负责人（只读）
- 风险提醒：编辑会影响所有绑定任务（可选二次确认：仅在修改关键字段时触发）

---

## 3.4 Tab1 表单：车辆及零件进出登记（Entry/Exit，支持共享）
**关键点**：这是“可共享对象”，UI 必须明确：**新建** vs **选择已有**；共享情况下必须提示影响范围。

### 3.4.1 打开方式与初始分支（在 Tab 内体现）
从主表行点【填写/查看表单】打开抽屉后，进入“进出登记”Tab 时：

**A. 未绑定 `entry_exit_id`（首次）**
- Tab 顶部显示“绑定方式”选择：
  - ( ) 新建进出登记（默认）
  - ( ) 选择已有进出登记（搜索选择：按 VIN/编号/时间/接收人）
- 若选择已有：
  - 展示只读预览（关键字段：VIN/编号、进入时间、接收人、处置类型、处置时间等）
  - [确认绑定] 按钮（绑定后写入主任务 `entry_exit_id`，并刷新闭环提示条）

**B. 已绑定 `entry_exit_id`**
- 直接进入编辑/查看
- 顶部显示共用提示（`active_mainrecord_count`）及影响范围提醒

### 3.4.2 字段分组（更易填写与审查）
- 关联信息（只读）
  - 车型 / VIN/零件编号 / 试验名称 / 关联主任务ID
- 进场信息
  - 接收人（默认=main.tester_name）
  - 进入时间（默认=main.schedule_start）
  - 用途（默认=测试）
- 出场信息（归还/报废）
  - 处置类型：报废 / 归还（单选）
  - 处置人（默认=当前登录人）
  - 处置时间（datetime）
  - 归还接受人（当“归还”时必填；报废时隐藏或置灰）
- 备注（单行）

### 3.4.3 状态与按钮（Tab 内）
底部按钮（位于 Tab 内容末尾）：
- [保存草稿]：status=DRAFT（弱校验）
- [提交/完成]：status=SUBMITTED（触发闭环刷新）
- 若允许撤回：显示 [撤回提交]（权限控制：安排人员；共享对象要提示影响范围）

业务规则建议：
- SUBMITTED 后默认只读（如需修改，必须撤回或由安排人员解锁）
- 若 EntryExit 共用且用户尝试编辑：弹窗提示“将影响 X 个任务”

---

## 3.5 Tab2 表单：试验信息登记（TestInfo，1 对 1）
**目标**：来源只读字段与必填编辑区明确分层；附件与勾选联动清晰；提交报错能定位；提交状态与闭环提示条联动。

### 3.5.1 页面结构（Tab 内结构）
- 顶部：闭环提示条（全局已固定，无需重复）
- 区块 1：来源字段（只读展示）
- 区块 2：必填信息（编辑）
- 区块 3：报告信息（编辑 + 联动）
- 区块 4：闭环关键附件（编辑 + 强校验）

### 3.5.2 来源字段（只读）
建议用两列信息卡（避免塞满不可编辑项）：

- 委托日期：main.schedule_start.date
- 任务单编号：main.contract_no
- 委托联系人：main.requester_name
- 样品编号：main.vin_or_part_no
- 项目平台：main.model
- 试验项目：main.test_name
- 送件人：main.requester_name
- 接收人：main.tester_name
- 入库时间：main.entry_exit.enter_time  
  - 若无 EntryExit：显示 `--` 并提示“请先在【进出登记】Tab 完成进出登记”
- 出库时间：main.entry_exit.dispose_time
- 出库接受人：main.entry_exit.return_receiver

> 这里特别强调 Tab 联动：EntryExit 完成绑定/保存后，TestInfo 的来源字段应支持刷新。

### 3.5.3 必填编辑区（示例）
- 联系方式*（手机号格式校验）
- NVH试验室管理号*
- 样品名称（零件/整车）
- 研发阶段（下拉：MULE、PRO、OTS、NS、S、不涉及）
- 送件部门*（下拉：部门A、部门B；也可直接填写）

### 3.5.4 报告区联动
- 是否出具试验/不确定度报告：是/否
  - 选否：报告编号自动填“/”并置灰
  - 选是：报告编号必填（或至少可编辑）

### 3.5.5 闭环关键勾选 + 附件（强校验）
- 是否包含拆装记录表：是/否
  - 是 → 上传【拆装记录表图片*】（必传）
- 是否包含试验过程记录表：是/否
  - 是 → “过程记录表清单组件”（至少 1 条）
    - 每条包含：
      - 表名（下拉选 TestProcessList；支持“输入即新增”）
      - 图片（必传）
    - 支持：新增 / 替换 / 删除 / 缩略图预览

组件提示：
- 在组件上方显示规则说明：“至少上传 1 张过程记录表图片”。

### 3.5.6 提交校验与报错体验
提交失败时：
- 顶部聚合错误提示：如“无法提交：缺少过程记录表图片（至少 1 张）”
- 对应字段区域红字提示 + 自动滚动定位
- 不清空用户已填内容

按钮（Tab 内底部）：
- [保存草稿]（不做强闭环校验，仅做基础格式校验）
- [提交/完成]（执行闭环强校验）
- [撤回提交]（ 状态可见性）

---

## 3.6 Tab3 表单：技术资料发放批准单（DocApproval，1 对 1）
**目标**：少字段、强附件、默认值合理；提交是闭环关键节点之一。

字段建议（含默认值）：
- 名称
- 编号：默认=主表合同编号（可改）
- 数量
- 接收人：默认=任务提出人（可改）
- 发放人：默认=当前登录人（可改）
- 批准人：默认=admin（可改）
- 发放日期：默认今天
- 文件地址(图片)*：上传控件（必传，支持图片，支持预览）

按钮（Tab 内底部）：
- [保存草稿]
- [提交/完成]（强制要求文件已上传）
- [撤回提交]

---

## 3.7（强制落地）统一“抽屉 + 页签”闭环工作流（最终体验说明）
**用户的主流程**应变为：

1) 在列表页筛选找到任务  
2) 点击【填写/查看表单】打开抽屉  
3) 抽屉顶部闭环提示条告诉用户缺什么  
4) 点击缺项 → 自动切到对应 Tab 并定位字段  
5) 在 Tab 内保存/提交  
6) 提交成功后：闭环提示条即时更新；列表 `is_closed` 也可刷新看到变化  
7) 用户无需离开列表页、无需跳转页面、无需重复找入口


---


## 2.5 UI 关键规则
1. 列表页展示 `is_closed`（直接读后端字段，不实时计算）。
2. 行内编辑权限：
   - 安排人员（白名单）可编辑主表关键字段（至少包含：车型、VIN、试验名称、加入预警系统、测试人员、合同号、安排时间等）
   - 其他只读
3. EntryExit 是共享对象：EntryExitForm 必须支持
   - “选择已有 / 新建”
   - 显示“已被 X 个任务共用”（X 来自后端 serializer 字段 `active_mainrecord_count`）

---

# 3. 验收点
1) 后端新增 `nvh_task` app 完整：models/serializers/services/views/urls + 总路由挂载  
2) 所有模型具备软删除字段与默认过滤逻辑（SoftDeleteModel + manager 生效）  
3) submit/unsubmit 正确刷新 `MainRecord.is_closed`，且 EntryExit submit/unsubmit 会刷新所有引用该 EntryExit 的 MainRecord  
4) 前端可从 BusinessCenter 与 MainLayout 进入模块  
5) 前端使用 Pinia 管理列表/表单/提交撤回/提示条数据  
6) 列表页只读 `is_closed`（不实时计算）  
7) 不需要 migration 文件，但代码应可 `makemigrations` 通过  

---


---
