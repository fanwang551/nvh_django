下面给你一套可直接替换/合并进你 app 的 **软删除版 Models**（DRF 项目适用），并补上**删除策略**要求：

- 所有表都有：`is_deleted`, `deleted_at`
- 默认查询 `objects` 自动过滤 `is_deleted=False`
- `MainRecord` 删除：允许，且**同步软删除 OneToOne 子表**（`TestInfo`、`DocApproval`）及其附件
- `EntryExit` 删除：**仅当它“活跃引用”的 MainRecord 数量 ≤ 1 时允许删除**；否则拒绝删除（抛异常/返回 400）

> 说明：下面代码只改 models 层 + 提供推荐的 DRF destroy 写法示例（你后续接到 ViewSet 即可）。你说“不做权限限制”，这里不加权限。

---

## 1) models.py（软删除基类 + 你的业务模型）

```python
from django.db import models
from django.utils import timezone
from django.core.exceptions import ValidationError

STATUS_DRAFT = "DRAFT"
STATUS_SUBMITTED = "SUBMITTED"


class SoftDeleteQuerySet(models.QuerySet):
    def delete(self):
        """批量软删除"""
        return super().update(is_deleted=True, deleted_at=timezone.now())

    def hard_delete(self):
        """物理删除（一般不用）"""
        return super().delete()

    def alive(self):
        return self.filter(is_deleted=False)

    def dead(self):
        return self.filter(is_deleted=True)


class SoftDeleteManager(models.Manager):
    """默认只返回未删除数据"""
    def get_queryset(self):
        return SoftDeleteQuerySet(self.model, using=self._db).filter(is_deleted=False)


class SoftDeleteModel(models.Model):
    is_deleted = models.BooleanField(default=False, db_index=True, verbose_name="是否删除(软删除)")
    deleted_at = models.DateTimeField(null=True, blank=True, verbose_name="删除时间")

    objects = SoftDeleteManager()
    all_objects = models.Manager()  # 包含已删除

    class Meta:
        abstract = True

    def soft_delete(self, using=None, keep_parents=False):
        """实例软删除"""
        if self.is_deleted:
            return
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save(update_fields=["is_deleted", "deleted_at"])

    def restore(self):
        """恢复（如将来需要）"""
        if not self.is_deleted:
            return
        self.is_deleted = False
        self.deleted_at = None
        self.save(update_fields=["is_deleted", "deleted_at"])


class EntryExit(SoftDeleteModel):
    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    enter_time = models.DateTimeField(null=True, blank=True, verbose_name="进入时间")
    purpose = models.CharField(max_length=100, null=True, blank=True, default="测试", verbose_name="用途")

    dispose_type = models.CharField(max_length=20, null=True, blank=True, verbose_name="报废/归还类型")
    disposer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="报废/归还人姓名")
    dispose_time = models.DateTimeField(null=True, blank=True, verbose_name="报废/归还时间")
    return_receiver = models.CharField(max_length=100, null=True, blank=True, verbose_name="归还接受人")

    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")
    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "车辆及零件进出登记"
        verbose_name_plural = "车辆及零件进出登记"

    def __str__(self):
        return f"EntryExit#{self.id}"

    def active_mainrecord_count(self) -> int:
        """
        活跃引用数量：只统计未软删除的 MainRecord
        related manager 会用 MainRecord.objects（默认过滤 is_deleted=False）
        """
        return self.main_records.count()

    def soft_delete(self, using=None, keep_parents=False):
        """
        EntryExit 删除规则：
        - 如果它活跃引用的 MainRecord > 1，则不允许删除
        - <=1 才允许软删除
        """
        if self.active_mainrecord_count() > 1:
            raise ValidationError("该进出登记被多条任务引用，不能删除。请先解绑或仅保留一条引用。")
        return super().soft_delete(using=using, keep_parents=keep_parents)


class MainRecord(SoftDeleteModel):
    model = models.CharField(max_length=100, verbose_name="车型")
    vin_or_part_no = models.CharField(max_length=100, db_index=True, verbose_name="VIN码/零件编号")
    test_name = models.CharField(max_length=200, verbose_name="试验名称")

    warning_system_status = models.CharField(max_length=20, verbose_name="加入预警系统状态")

    requester_name = models.CharField(max_length=100, verbose_name="任务提出人")
    schedule_start = models.DateTimeField(db_index=True, verbose_name="试验安排开始时间")
    schedule_end = models.DateTimeField(null=True, blank=True, verbose_name="试验安排结束时间")
    schedule_remark = models.CharField(max_length=500, null=True, blank=True, verbose_name="试验安排时间备注")
    test_location = models.CharField(max_length=200, null=True, blank=True, verbose_name="试验地点")

    tester_name = models.CharField(max_length=100, verbose_name="测试人员")
    contract_no = models.CharField(max_length=100, null=True, blank=True, db_index=True, verbose_name="合同编号")
    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")

    entry_exit = models.ForeignKey(
        "EntryExit",
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="main_records",
        verbose_name="关联进出登记",
    )

    is_closed = models.BooleanField(default=False, db_index=True, verbose_name="是否闭环")
    closure_checked_at = models.DateTimeField(null=True, blank=True, verbose_name="闭环判断更新时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "任务主记录"
        verbose_name_plural = "任务主记录"

    def __str__(self):
        return f"MainRecord#{self.id} {self.vin_or_part_no} {self.test_name}"

    def soft_delete(self, using=None, keep_parents=False):
        """
        主记录删除允许，并同步软删除 OneToOne 子表：
        - TestInfo（以及它的附件）
        - DocApproval
        注意：EntryExit 不删除（共享对象）
        """
        # 先软删子表（存在才删）
        if hasattr(self, "test_info") and self.test_info and not self.test_info.is_deleted:
            self.test_info.soft_delete()
        if hasattr(self, "doc_approval") and self.doc_approval and not self.doc_approval.is_deleted:
            self.doc_approval.soft_delete()

        # 再软删自己
        return super().soft_delete(using=using, keep_parents=keep_parents)


class TestInfo(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="test_info",
        verbose_name="关联主任务",
    )

    contact_phone = models.CharField(max_length=50, verbose_name="联系方式")
    nvh_lab_mgmt_no = models.CharField(max_length=100, db_index=True, verbose_name="NVH试验室管理号")

    sample_type = models.CharField(max_length=20, verbose_name="样品名称")
    rd_stage = models.CharField(max_length=20, verbose_name="研发阶段")
    delivery_dept = models.CharField(max_length=200, verbose_name="送件部门")

    report_required = models.CharField(max_length=20, verbose_name="是否出具试验/不确定度报告")
    report_no = models.CharField(max_length=100, default="/", verbose_name="报告编号")

    include_teardown_record = models.CharField(max_length=20, default="否", verbose_name="是否包含拆装记录表")
    include_process_record = models.CharField(max_length=20, default="否", verbose_name="是否包含试验过程记录表")
    teardown_attachment_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="拆装记录表附件URL")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "试验信息登记"
        verbose_name_plural = "试验信息登记"

    def __str__(self):
        return f"TestInfo(main_id={self.main_id})"

    def soft_delete(self, using=None, keep_parents=False):
        """
        同步软删除附件（ForeignKey 一对多）
        related manager 默认只拿未删除的附件，因此这里直接 all_objects 更稳妥
        """
        TestProcessAttachment.all_objects.filter(test_info_id=self.id, is_deleted=False).update(
            is_deleted=True, deleted_at=timezone.now()
        )
        return super().soft_delete(using=using, keep_parents=keep_parents)


class TestProcessAttachment(SoftDeleteModel):
    test_info = models.ForeignKey(
        "TestInfo",
        on_delete=models.CASCADE,
        related_name="process_attachments",
        verbose_name="关联试验信息",
    )
    record_name = models.CharField(max_length=200, verbose_name="过程记录表名")
    file_url = models.CharField(max_length=1024, verbose_name="图片URL")
    sort_no = models.PositiveIntegerField(default=0, verbose_name="排序号")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        verbose_name = "试验过程记录附件"
        verbose_name_plural = "试验过程记录附件"

    def __str__(self):
        return f"TPA#{self.id} {self.record_name}"


class TestProcessList(SoftDeleteModel):
    test_process_name = models.CharField(max_length=200, verbose_name="过程记录表名")

    class Meta:
        verbose_name = "试验过程记录表清单"
        verbose_name_plural = "试验过程记录表清单"

    def __str__(self):
        return f"TPL#{self.id} {self.test_process_name}"


class DocApproval(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="doc_approval",
        verbose_name="关联主任务",
    )

    doc_name = models.CharField(max_length=200, verbose_name="名称")
    doc_no = models.CharField(max_length=100, null=True, blank=True, verbose_name="编号")
    quantity = models.PositiveIntegerField(null=True, blank=True, verbose_name="数量")

    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    issuer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="发放人")
    approver_name = models.CharField(max_length=100, default="admin", verbose_name="批准人")
    issue_date = models.DateField(verbose_name="发放日期")

    file_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="文件地址(图片URL)")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "技术资料发放批准单"
        verbose_name_plural = "技术资料发放批准单"

    def __str__(self):
        return f"DocApproval(main_id={self.main_id})"
```

---

## 2) DRF 删除接口推荐写法（destroy 走 soft_delete + 规则校验）

你说项目是 DRF，这里给你最常用的两种 ViewSet destroy 写法示例（你可以直接套到对应 ViewSet 里）。

### 2.1 MainRecord：destroy 同步软删 OneToOne（已在 model.soft_delete 里做了）
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from .models import MainRecord

class MainRecordViewSet(viewsets.ModelViewSet):
    queryset = MainRecord.objects.all()  # 默认不含已删除
    # serializer_class = ...

    def destroy(self, request, *args, **kwargs):
        obj = self.get_object()
        obj.soft_delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

### 2.2 EntryExit：destroy 只有“活跃引用<=1”才允许删除
```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from .models import EntryExit

class EntryExitViewSet(viewsets.ModelViewSet):
    queryset = EntryExit.objects.all()
    # serializer_class = ...

    def destroy(self, request, *args, **kwargs):
        obj = self.get_object()
        try:
            obj.soft_delete()
        except Exception as e:
            # 如果你想更精确，可以捕获 django.core.exceptions.ValidationError
            raise ValidationError(str(e))
        return Response(status=status.HTTP_204_NO_CONTENT)
```

---

## 3) 需要你确认的一个关键点（避免你后续“删除不了/删错”）
你说的规则是：

> “entryexit如果只对应一条主表记录可以删除否则不删除”

我上面实现的是：**只统计“未软删除的 MainRecord”引用**（活跃引用）：
- 如果 EntryExit 之前被多个 MainRecord 用过，但那些 MainRecord 都已经软删除了，则 EntryExit 现在活跃引用可能为 0，此时允许删除。

请确认这是否符合你们预期？  
- 若你要按“历史上绑定过的总数（含已删除主记录）”来限制，则需要把 `active_mainrecord_count()` 改成用 `MainRecord.all_objects` 统计。

下面给你一份“更清晰、可执行、可交付”的优化版提示词（Prompt）。我把你上面已经定好的业务/模型/UI/接口要求做了结构化，同时补上了**软删除字段**与默认查询规则，避免后端/前端实现时歧义。

---

## 优化版提示词（可直接发给开发/AI 生成代码）

你要在现有 Django + Vue 项目中实现“试验任务管理”模块。请严格按以下要求完成后端与前端代码改造，**不需要执行迁移**，但代码必须完整可读、可落地。

# 0. 项目约束与已知信息
- 现有前端：`frontend/src/store/index.js` 的接口可获取 `username` 和 `fullname`（用于默认填充发放人/报废人等字段），可以保存到自己的store中。
- 技术栈：
  - 后端：Django（apps 结构）
  - 前端：Vue（在 `frontend/src/views/business` 写页面），Pinia（在 `frontend/src/store`）
- **不要执行迁移**（即无需给出 migration 文件），但模型/接口/前端代码要完整。

---

# 1. 后端：新增 app + Models（含软删除）

## 1.1 新建后端 app
- 在 `backend/apps/` 下新建一个 app（名称 `nvh_task` ），并完成：
  - 模型文件 `models.py`
  - 序列化/接口（如使用 DRF：serializers.py / views.py / urls.py）
  - service 层（建议 `services.py`）封装“提交/撤回/闭环刷新”等业务逻辑
  - 将路由挂到项目总路由中

## 1.2 Models：按以下关系实现（保留你的设计，不要改关系）
核心要点必须满足：
- `MainRecord.entry_exit`：可空 `ForeignKey`；**一个 EntryExit 可被多条 MainRecord 引用**
- `MainRecord` ↔ `TestInfo`：OneToOne
- `MainRecord` ↔ `DocApproval`：OneToOne
- `TestInfo` ↔ `TestProcessAttachment`：一对多
- 闭环字段 `MainRecord.is_closed`：**只在提交/撤回/更换 entry_exit 时刷新一次**；列表页直接读该字段
- 状态字段：`status` 只用字符串 `DRAFT|SUBMITTED`（前端管理枚举，不加 choices，但保留常量）


---

## 1) 软删除基类（抽象基类 + QuerySet + Manager）伪代码

> 可直接放在 `models.py` 顶部其他合适位置也可以。

```python
from django.db import models, transaction
from django.utils import timezone


class SoftDeleteQuerySet(models.QuerySet):
    def delete(self):
        """QuerySet 批量删除时，默认做软删除"""
        return super().update(is_deleted=True, deleted_at=timezone.now())

    def hard_delete(self):
        """物理删除（一般不用）"""
        return super().delete()

    def alive(self):
        return self.filter(is_deleted=False)

    def dead(self):
        return self.filter(is_deleted=True)


class SoftDeleteManager(models.Manager):
    """默认只返回未删除数据"""
    def get_queryset(self):
        return SoftDeleteQuerySet(self.model, using=self._db).filter(is_deleted=False)


class SoftDeleteModel(models.Model):
    is_deleted = models.BooleanField(default=False, db_index=True)
    deleted_at = models.DateTimeField(null=True, blank=True)

    objects = SoftDeleteManager()     # 默认过滤 is_deleted=False
    all_objects = models.Manager()    # 可查询全部（含已删除）

    class Meta:
        abstract = True

    def delete(self, using=None, keep_parents=False):
        """
        兜底：任何地方调用 instance.delete() 也走软删除，避免误物理删除
        """
        return self.soft_delete(using=using, keep_parents=keep_parents)

    def soft_delete(self, using=None, keep_parents=False):
        """实例软删除"""
        if self.is_deleted:
            return
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save(update_fields=["is_deleted", "deleted_at"])

    def restore(self):
        """恢复（如将来需要）"""
        if not self.is_deleted:
            return
        self.is_deleted = False
        self.deleted_at = None
        self.save(update_fields=["is_deleted", "deleted_at"])

    def hard_delete(self, using=None, keep_parents=False):
        """物理删除（一般不用）"""
        return super().delete(using=using, keep_parents=keep_parents)
```

---

## 2) 模型接入软删除 + 明确级联策略

### 2.1 EntryExit（限制删除：活跃引用的 MainRecord > 1 禁止软删）

```python
from django.db import models
from django.utils import timezone
from django.core.exceptions import ValidationError

STATUS_DRAFT = "DRAFT"
STATUS_SUBMITTED = "SUBMITTED"


class EntryExit(SoftDeleteModel):
    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    enter_time = models.DateTimeField(null=True, blank=True, verbose_name="进入时间")
    purpose = models.CharField(max_length=100, null=True, blank=True, default="测试", verbose_name="用途")

    dispose_type = models.CharField(max_length=20, null=True, blank=True, verbose_name="报废/归还类型")
    disposer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="报废/归还人姓名")
    dispose_time = models.DateTimeField(null=True, blank=True, verbose_name="报废/归还时间")
    return_receiver = models.CharField(max_length=100, null=True, blank=True, verbose_name="归还接受人")

    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")
    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "车辆及零件进出登记"
        verbose_name_plural = "车辆及零件进出登记"

    def __str__(self):
        return f"EntryExit#{self.id}"

    def active_mainrecord_count(self) -> int:
        """
        只统计未软删除的 MainRecord：
        related manager 会使用 MainRecord.objects（默认过滤 is_deleted=False）
        """
        return self.main_records.count()

    def soft_delete(self, using=None, keep_parents=False):
        """
        EntryExit 删除规则：
        - 活跃引用的 MainRecord > 1：禁止删除（避免共享对象被多个任务引用时删除）
        - <= 1：允许软删除
        """
        if self.active_mainrecord_count() > 1:
            raise ValidationError("该进出登记被多条任务引用，不能删除。请先解绑或仅保留一条引用。")
        return super().soft_delete(using=using, keep_parents=keep_parents)
```

---

### 2.2 MainRecord（软删时同步软删 OneToOne 子表：TestInfo / DocApproval；不动 EntryExit）

```python
class MainRecord(SoftDeleteModel):
    model = models.CharField(max_length=100, verbose_name="车型")
    vin_or_part_no = models.CharField(max_length=100, db_index=True, verbose_name="VIN码/零件编号")
    test_name = models.CharField(max_length=200, verbose_name="试验名称")

    warning_system_status = models.CharField(max_length=20, verbose_name="加入预警系统状态")

    requester_name = models.CharField(max_length=100, verbose_name="任务提出人")
    schedule_start = models.DateTimeField(db_index=True, verbose_name="试验安排开始时间")
    schedule_end = models.DateTimeField(null=True, blank=True, verbose_name="试验安排结束时间")
    schedule_remark = models.CharField(max_length=500, null=True, blank=True, verbose_name="试验安排时间备注")
    test_location = models.CharField(max_length=200, null=True, blank=True, verbose_name="试验地点")

    tester_name = models.CharField(max_length=100, verbose_name="测试人员")
    contract_no = models.CharField(max_length=100, null=True, blank=True, db_index=True, verbose_name="合同编号")
    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")

    entry_exit = models.ForeignKey(
        "EntryExit",
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="main_records",
        verbose_name="关联进出登记",
    )

    is_closed = models.BooleanField(default=False, db_index=True, verbose_name="是否闭环")
    closure_checked_at = models.DateTimeField(null=True, blank=True, verbose_name="闭环判断更新时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "任务主记录"
        verbose_name_plural = "任务主记录"

    def __str__(self):
        return f"MainRecord#{self.id} {self.vin_or_part_no} {self.test_name}"

    def soft_delete(self, using=None, keep_parents=False):
        """
        主记录软删除策略：
        - 不物理删除关联 EntryExit（共享对象）
        - 同步软删除 OneToOne：TestInfo、DocApproval
        - TestInfo 内部会继续软删附件 TestProcessAttachment（见下）
        """
        with transaction.atomic():
            # 先软删子表
            if hasattr(self, "test_info") and self.test_info and not self.test_info.is_deleted:
                self.test_info.soft_delete()
            if hasattr(self, "doc_approval") and self.doc_approval and not self.doc_approval.is_deleted:
                self.doc_approval.soft_delete()

            # 再软删自己
            return super().soft_delete(using=using, keep_parents=keep_parents)
```

---

### 2.3 TestInfo（软删时同步软删附件 TestProcessAttachment）

```python
class TestInfo(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="test_info",
        verbose_name="关联主任务",
    )

    contact_phone = models.CharField(max_length=50, verbose_name="联系方式")
    nvh_lab_mgmt_no = models.CharField(max_length=100, db_index=True, verbose_name="NVH试验室管理号")

    sample_type = models.CharField(max_length=20, verbose_name="样品名称")
    rd_stage = models.CharField(max_length=20, verbose_name="研发阶段")
    delivery_dept = models.CharField(max_length=200, verbose_name="送件部门")

    report_required = models.CharField(max_length=20, verbose_name="是否出具试验/不确定度报告")
    report_no = models.CharField(max_length=100, default="/", verbose_name="报告编号")

    include_teardown_record = models.CharField(max_length=20, default="否", verbose_name="是否包含拆装记录表")
    include_process_record = models.CharField(max_length=20, default="否", verbose_name="是否包含试验过程记录表")
    teardown_attachment_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="拆装记录表附件URL")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "试验信息登记"
        verbose_name_plural = "试验信息登记"

    def __str__(self):
        return f"TestInfo(main_id={self.main_id})"

    def soft_delete(self, using=None, keep_parents=False):
        """
        同步软删除附件（ForeignKey 一对多）
        用 all_objects 更稳妥（避免默认 manager 过滤导致漏更新）
        """
        with transaction.atomic():
            TestProcessAttachment.all_objects.filter(
                test_info_id=self.id, is_deleted=False
            ).update(is_deleted=True, deleted_at=timezone.now())

            return super().soft_delete(using=using, keep_parents=keep_parents)
```

---

### 2.4 其余模型：直接继承 SoftDeleteModel 即可

```python
class TestProcessAttachment(SoftDeleteModel):
    test_info = models.ForeignKey(
        "TestInfo",
        on_delete=models.CASCADE,
        related_name="process_attachments",
        verbose_name="关联试验信息",
    )
    record_name = models.CharField(max_length=200, verbose_name="过程记录表名")
    file_url = models.CharField(max_length=1024, verbose_name="图片URL")
    sort_no = models.PositiveIntegerField(default=0, verbose_name="排序号")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        verbose_name = "试验过程记录附件"
        verbose_name_plural = "试验过程记录附件"


class TestProcessList(SoftDeleteModel):
    test_process_name = models.CharField(max_length=200, verbose_name="过程记录表名")

    class Meta:
        verbose_name = "试验过程记录表清单"
        verbose_name_plural = "试验过程记录表清单"


class DocApproval(SoftDeleteModel):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="doc_approval",
        verbose_name="关联主任务",
    )

    doc_name = models.CharField(max_length=200, verbose_name="名称")
    doc_no = models.CharField(max_length=100, null=True, blank=True, verbose_name="编号")
    quantity = models.PositiveIntegerField(null=True, blank=True, verbose_name="数量")

    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    issuer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="发放人")
    approver_name = models.CharField(max_length=100, default="admin", verbose_name="批准人")
    issue_date = models.DateField(verbose_name="发放日期")

    file_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="文件地址(图片URL)")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "技术资料发放批准单"
        verbose_name_plural = "技术资料发放批准单"
```

---

## 3) DRF 接口：destroy 强制调用 soft_delete（不走物理删除）

### 3.1 MainRecordViewSet

```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from .models import MainRecord

class MainRecordViewSet(viewsets.ModelViewSet):
    queryset = MainRecord.objects.all()  # 默认已过滤 is_deleted=False
    # serializer_class = ...

    def destroy(self, request, *args, **kwargs):
        obj = self.get_object()
        obj.soft_delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

### 3.2 EntryExitViewSet（引用>1 时返回 400）

```python
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError as DRFValidationError
from django.core.exceptions import ValidationError as DjangoValidationError
from .models import EntryExit

class EntryExitViewSet(viewsets.ModelViewSet):
    queryset = EntryExit.objects.all()
    # serializer_class = ...

    def destroy(self, request, *args, **kwargs):
        obj = self.get_object()
        try:
            obj.soft_delete()
        except DjangoValidationError as e:
            raise DRFValidationError(e.message)
        return Response(status=status.HTTP_204_NO_CONTENT)
```


---

## 2. 后端：接口与业务规则（最小可用集合）

### 2.1 get_or_create 策略（避免 OneToOne 空对象）
- `GET /main-record/{id}/test-info`：不存在则创建 DRAFT 返回
- `GET /main-record/{id}/doc-approval`：同上
- EntryExit：
  - 如果 `main.entry_exit_id` 为空：前端需“新建/选择已有”后再 `PATCH main.entry_exit_id=xxx`

### 2.2 提交/撤回接口（统一模式）
为三张表提供：
- `POST /entry-exit/{id}/submit`、`POST /entry-exit/{id}/unsubmit`
- `POST /test-info/{id}/submit`、`POST /test-info/{id}/unsubmit`
- `POST /doc-approval/{id}/submit`、`POST /doc-approval/{id}/unsubmit`

提交成功后：
- `status=SUBMITTED`、`submitted_at=now()`（有 submitted_at 的表才写）
- 必须调用 `refresh_main_closed(...)` 刷新闭环

撤回提交成功后：
- `status=DRAFT`
- 必须调用 `refresh_main_closed(...)` 刷新闭环（通常会变 False）

### 2.3 闭环刷新规则（严格按此实现）
闭环条件：
- `is_closed = (entry_exit存在且SUBMITTED) AND (test_info存在且SUBMITTED) AND (doc_approval存在且SUBMITTED)`

刷新触发点（只在这些时机刷新）：
- 任意一个表单 submit 成功
- 任意一个表单 unsubmit 成功
- MainRecord 更换/解绑 entry_exit

EntryExit 共享刷新（必须实现）：
- EntryExit submit/unsubmit 时，刷新所有 `entry_exit.main_records` 引用的主任务闭环状态

### 2.4 提交校验（把 Excel 痛点变系统规则）
- TestInfo submit 校验：
  - `include_teardown_record == "是"` → `teardown_attachment_url` 必须有
  - `include_process_record == "是"` → 至少 1 条 `TestProcessAttachment`
  - `report_required == "否"` → `report_no` 必须为 `/`（前端可自动处理，但后端也要兜底）
- DocApproval submit 校验：
  - `file_url` 必须有
- EntryExit submit 校验：
  - 可只校验关键字段（按你实现时的合理默认；模型字段仍允许为空）

---

## 3. 前端：新增页面 + Pinia + 入口挂载

### 3.1 页面位置
- 在 `frontend/src/views/business/` 下新增对应 Vue 页面（建议：
  - `TaskMainList.vue` 主列表页
  - `EntryExitForm.vue`、`TestInfoForm.vue`、`DocApprovalForm.vue` 表单抽屉页面）
- 使用 Pinia：在 `frontend/src/store/` 新增 store（例如 `useTaskStore`），统一管理：
  - 主列表查询与分页
  - 行内编辑（仅安排人员可编辑）
  - 三表单 get_or_create 获取、保存草稿、提交/撤回
  - 闭环状态显示与原因提示数据

### 3.2 BusinessCenter 入口
- 在 `frontend/src/views/BusinessCenter.vue` 中添加该模块入口（按钮/菜单卡片等）
- 在 `frontend/src/components/layout/MainLayout.vue` 添加对应标签/菜单项（能进入 BusinessCenter 或直接进入任务管理页，按现有项目导航结构适配）

### 3.3 UI 关键要求
- 主表列表页：支持筛选 + 展示 `is_closed`（不实时计算，读字段）
- 行内编辑权限：
  - 安排人员：可编辑主表关键字段，可以使用`frontend/src/store/index.js` 的接口可获取 `username` 和 `fullname`（用于判断权限），后端接口`backend/apps/users/views.py`中user_info接口也可获取用户信息，可以使用username in []实现权限控制
  - 试验人员：只读
- 三个表单顶部要有“闭环提示条”：
  - 显示三表状态（已提交/未提交）
  - 显示 TestInfo 附件齐全性
  - 显示未闭环原因列表（可点击定位到对应字段/附件区）
- EntryExit 是共享对象：表单需要支持“选择已有 / 新建”，并显示“已被 X 个任务共用”

---

## 4. 交付标准（验收点）
1) 后端 app 新增完成，models/接口/service 代码齐全
2) 所有模型具备软删除字段与默认过滤逻辑
3) submit/unsubmit 会正确刷新 `MainRecord.is_closed`，且 EntryExit 共享刷新正确
4) 前端页面可从 BusinessCenter 与 MainLayout 进入
5) 前端使用 Pinia 管理数据与接口调用
6) 列表页直接读取 `is_closed`，不做实时计算
7) 不需要 migration，但代码必须能迁移通过（字段/关系合法）

---

