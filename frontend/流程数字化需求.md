

## 一、Models（按 verbose_name 关键字参数统一 + 保留你要的关系）

要点保持不变：
- `MainRecord.entry_exit`：允许为空 `ForeignKey`，**EntryExit 可被多条 MainRecord 引用**
- `MainRecord` ↔ `TestInfo`：OneToOne
- `MainRecord` ↔ `DocApproval`：OneToOne
- `TestInfo` ↔ `TestProcessAttachment`：1对多
- “闭环”用 `MainRecord.is_closed` 存储，**只在提交/撤回时刷新一次**，列表页直接读该字段

> 说明：下面依旧不加 choices（前端管枚举值），但我保留常量，避免手写字符串散落。

```python
from django.db import models

STATUS_DRAFT = "DRAFT"
STATUS_SUBMITTED = "SUBMITTED"


class EntryExit(models.Model):
    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    enter_time = models.DateTimeField(null=True, blank=True, verbose_name="进入时间")
    purpose = models.CharField(max_length=100, null=True, blank=True, default="测试", verbose_name="用途")

    dispose_type = models.CharField(max_length=20, null=True, blank=True, verbose_name="报废/归还类型")  # 报废/归还（前端控制）
    disposer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="报废/归还人姓名")
    dispose_time = models.DateTimeField(null=True, blank=True, verbose_name="报废/归还时间")
    return_receiver = models.CharField(max_length=100, null=True, blank=True, verbose_name="归还接受人")

    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")
    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "车辆及零件进出登记"
        verbose_name_plural = "车辆及零件进出登记"

    def __str__(self):
        return f"EntryExit#{self.id}"


class MainRecord(models.Model):
    model = models.CharField(max_length=100, verbose_name="车型")
    vin_or_part_no = models.CharField(max_length=100, db_index=True, verbose_name="VIN码/零件编号")
    test_name = models.CharField(max_length=200, verbose_name="试验名称")

    warning_system_status = models.CharField(max_length=20, verbose_name="加入预警系统状态")  # 前端控制枚举

    requester_name = models.CharField(max_length=100, verbose_name="任务提出人")
    schedule_start = models.DateTimeField(db_index=True, verbose_name="试验安排开始时间")
    schedule_end = models.DateTimeField(null=True, blank=True, verbose_name="试验安排结束时间")
    schedule_remark = models.CharField(max_length=500, null=True, blank=True, verbose_name="试验安排时间备注")
    test_location = models.CharField(max_length=200, null=True, blank=True, verbose_name="试验地点")

    tester_name = models.CharField(max_length=100, verbose_name="测试人员")
    contract_no = models.CharField(max_length=100, null=True, blank=True, db_index=True, verbose_name="合同编号")
    remark = models.CharField(max_length=1000, null=True, blank=True, verbose_name="备注")

    entry_exit = models.ForeignKey(
        "EntryExit",
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="main_records",
        verbose_name="关联进出登记",
    )

    is_closed = models.BooleanField(default=False, db_index=True, verbose_name="是否闭环")
    closure_checked_at = models.DateTimeField(null=True, blank=True, verbose_name="闭环判断更新时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "任务主记录"
        verbose_name_plural = "任务主记录"

    def __str__(self):
        return f"MainRecord#{self.id} {self.vin_or_part_no} {self.test_name}"


class TestInfo(models.Model):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="test_info",
        verbose_name="关联主任务",
    )

    contact_phone = models.CharField(max_length=50, verbose_name="联系方式")
    nvh_lab_mgmt_no = models.CharField(max_length=100, db_index=True, verbose_name="NVH试验室管理号")

    sample_type = models.CharField(max_length=20, verbose_name="样品名称")  
    rd_stage = models.CharField(max_length=20, verbose_name="研发阶段")    
    delivery_dept = models.CharField(max_length=200, verbose_name="送件部门")

    report_required = models.CharField(max_length=20, verbose_name="是否出具试验/不确定度报告")
    report_no = models.CharField(max_length=100, default="/", verbose_name="报告编号")

    include_teardown_record = models.CharField(max_length=20, default="否", verbose_name="是否包含拆装记录表")
    include_process_record = models.CharField(max_length=20, default="否", verbose_name="是否包含试验过程记录表")
    teardown_attachment_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="拆装记录表附件URL")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "试验信息登记"
        verbose_name_plural = "试验信息登记"

    def __str__(self):
        return f"TestInfo(main_id={self.main_id})"


class TestProcessAttachment(models.Model):
    test_info = models.ForeignKey(
        "TestInfo",
        on_delete=models.CASCADE,
        related_name="process_attachments",
        verbose_name="关联试验信息",
    )
    record_name = models.CharField(max_length=200, verbose_name="过程记录表名")
    file_url = models.CharField(max_length=1024, verbose_name="图片URL")
    sort_no = models.PositiveIntegerField(default=0, verbose_name="排序号")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        verbose_name = "试验过程记录附件"
        verbose_name_plural = "试验过程记录附件"

    def __str__(self):
        return f"TPA#{self.id} {self.record_name}"

class TestProcessList(models.Model):
    test_process_name = models.CharField(max_length=200, verbose_name="过程记录表名")
    
    class Meta:
        verbose_name = "试验过程记录表清单"
        verbose_name_plural = "试验过程记录表清单"

    def __str__(self):
        return f"TPL#{self.id} {self.test_process_name}"

class DocApproval(models.Model):
    main = models.OneToOneField(
        "MainRecord",
        on_delete=models.CASCADE,
        related_name="doc_approval",
        verbose_name="关联主任务",
    )

    doc_name = models.CharField(max_length=200, verbose_name="名称")
    doc_no = models.CharField(max_length=100, null=True, blank=True, verbose_name="编号")
    quantity = models.PositiveIntegerField(null=True, blank=True, verbose_name="数量")

    receiver_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="接收人")
    issuer_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="发放人")
    approver_name = models.CharField(max_length=100, default="admin", verbose_name="批准人")
    issue_date = models.DateField(verbose_name="发放日期")

    file_url = models.CharField(max_length=1024, null=True, blank=True, verbose_name="文件地址(图片URL)")

    status = models.CharField(max_length=20, default=STATUS_DRAFT, db_index=True, verbose_name="表单状态")
    submitted_at = models.DateTimeField(null=True, blank=True, verbose_name="提交时间")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        verbose_name = "技术资料发放批准单"
        verbose_name_plural = "技术资料发放批准单"

    def __str__(self):
        return f"DocApproval(main_id={self.main_id})"
```

---

## 二、业务设计（流程、状态机、闭环刷新）

### 2.1 角色与权限（建议最小可用）
| 动作 | 安排人员 | 试验人员 |
|---|---:|---:|
| 新增/删除 MainRecord | 允许 | 禁止 |
| 主表行内编辑（车型/VIN/试验名称/排期等） | 允许 | 只读 |
| 进入三个表单 | 允许 | 允许 |
| 保存草稿 | 允许 | 允许 |
| 提交/撤回提交（3个表单） | 允许（可选） | 允许 |
| 更换/解绑 EntryExit（若需要） | 允许 | 禁止 |

> 你要的“列表可编辑表格”对权限很敏感：**行内编辑只给安排人员**，试验人员只能看 + 点按钮进表单填写。

---

### 2.2 状态机与闭环规则（速度优先、不重复计算）
- 三张表（`EntryExit/TestInfo/DocApproval`）统一：`status = DRAFT | SUBMITTED`
- `MainRecord.is_closed`：**不做列表实时计算**，仅在以下事件发生时刷新一次：
  - 任何一个表单提交成功
  - 任何一个表单撤回提交（从 SUBMITTED → DRAFT）
  - 主表更换 entry_exit（因为闭环判断引用变了）

闭环判断：
- `is_closed = (entry_exit存在且SUBMITTED) AND (test_info存在且SUBMITTED) AND (doc_approval存在且SUBMITTED)`

> 注意：`EntryExit` 允许被多个主任务引用，因此它一旦 SUBMITTED，会“同时影响”多条主任务闭环判断——这是共享的必然结果。UI 上必须提示“该进出登记已绑定 X 个任务”。

---

### 2.3 “提交”校验规则（把 Excel 时代的“缺附件”痛点变成系统规则）
提交按钮含义：**提交=完成/可用于闭环判断**。

- EntryExit 提交：可只校验关键字段（例如 enter_time、dispose_type 等是否必填由你们流程决定；你现在模型允许空，UI 可在提交时强校验）
- TestInfo 提交：必须校验“闭环关键附件”
  - `include_teardown_record == 是` → `teardown_attachment_url` 必须有
  - `include_process_record == 是` → 至少 1 条 `TestProcessAttachment`
  - `report_required == 否` → `report_no` 必须为 `/`（UI 自动处理）
- DocApproval 提交：
  - `file_url` 必须有

撤回提交：
- 允许把 `status` 改回 `DRAFT`（同时刷新 `MainRecord.is_closed=False`）


---

## 三、UI 设计（草图 + 关键交互）

### 3.1 主界面（主表列表页）
目标：替代 Excel 目录表 + 分发表单填写入口 + 闭环一眼可见。

```
页面标题：试验任务管理

[筛选区]
车型(下拉/搜索)  VIN/零件编号(搜索)  试验名称(搜索)  测试人员(搜索)
排期开始(日期范围)  闭环状态(全部/未闭环/已闭环)  预警状态(多选)
[查询] [重置]                               [新增主记录]

[主表列表 - 可编辑表格（安排人员）]
| 闭环 | 车型 | VIN/零件编号 | 试验名称 | 预警系统 | 任务提出人 | 开始时间 | 结束时间 |
| 地点 | 测试人员 | 合同编号 | 是否拆装(派生) | 是否过程(派生) | 备注 | 操作 |
|-----|------|-------------|---------|---------|-----------|---------|---------|
| 绿点 已闭环 / 红点 未闭环 ...                                         | [进入表单] |

操作列（按钮组）：
- [进出登记] [试验信息] [技术资料]  （抽屉/新页均可，推荐抽屉）
- [删除]（仅安排人员）
- 行内编辑：仅安排人员可编辑；试验人员只读
```

**派生列显示规则（不引入闭环重复计算）**
- 是否拆装：来自 `TestInfo.include_teardown_record`（无 TestInfo 时显示 `--`）
- 是否过程：来自 `TestInfo.include_process_record`（无 TestInfo 时显示 `--`）
> 列表接口可 `select_related('test_info')` 拿到，不需要复杂统计。

---

### 3.2 进入任意表单后的“闭环提示条”（核心体验）
三个表单顶部固定一条“闭环提示条”，**让试验人员不用来回问/翻 Excel**：

```
[闭环提示条 - 固定在抽屉/页面顶部]
进出登记： 未提交 / 已提交
试验信息： 未提交 / 已提交
  - 拆装记录：不需要 / 附件缺失 / 齐全
  - 过程记录：不需要 / 附件缺失(0/至少1) / 齐全
技术资料： 未提交 / 已提交（文件缺失/已上传）

未闭环原因（一键提示）：
- 缺少：试验过程记录表图片（至少1张）
- 缺少：技术资料发放批准单文件
...
```

交互建议：
- 若用户点击“未闭环原因”某一项 → 自动滚动/聚焦到对应字段或附件组件。
- 若 EntryExit 被多任务共用，在提示条旁显示：
  - “该进出登记已被 X 个任务共用（展开）”

---

### 3.3 表单一：车辆及零件进出登记（Entry/Exit）
关键点：它是“可共享对象”，因此 UI 必须支持“选择已有 or 新建”。

**进入方式（推荐）**
- 点击主表行的【进出登记】
- 打开抽屉：
  - 若 `main.entry_exit_id` 为空：显示“新建/选择已有”
  - 若不为空：直接编辑该 EntryExit，并提示共用情况

草图：
```
标题：车辆及零件进出登记
副标题：关联主任务：{车型} / {VIN} / {试验名称}

[关联信息-只读]
车型：{main.model}    VIN/零件编号：{main.vin_or_part_no}
试验名称：{main.test_name}

[共用提示（当 EntryExit 被多个主任务引用）]
已绑定 {N} 个任务  [展开查看任务列表]

[可编辑字段]
接收人： [默认=main.tester_name]
进入时间： [默认=main.schedule_start]
用途： [默认=测试]
报废/归还： (√选) 报废 / 归还
报废/归还人姓名： [默认=当前登录人]
报废/归还时间： (datetime)
归还接受人： (文本)
备注： (多行)

[底部按钮]
[保存草稿]   [提交/完成]
（提交后 status=SUBMITTED，并触发相关 MainRecord 闭环刷新）
```

> 如果你们业务允许“进出登记提交后不允许修改”，可在 UI 上 SUBMITTED 状态只读 + “撤回提交”按钮（需要权限）。

---

### 3.4 表单二：试验信息登记（TestInfo）
草图（按你需求拆分只读来源区 + 必填编辑区 + 闭环关键附件区）：

```
标题：试验信息登记（与主表 1对1）

[来源字段-只读展示]
委托日期：{main.schedule_start.date}
任务单编号：{main.contract_no}
委托联系人：{main.requester_name}
样品编号：{main.vin_or_part_no}
项目平台：{main.model}
试验项目：{main.test_name}
送件人：{main.requester_name}
接收人：{main.tester_name}
入库时间：{main.entry_exit.enter_time}
出库时间：{main.entry_exit.dispose_time}
出库接受人：{main.entry_exit.return_receiver}

[必填编辑区]
联系方式*：
NVH试验室管理号*：
样品名称：零件/整车
研发阶段：下拉（MULE、PRO、OTS、NS、S、不涉及 ）
送件部门*：

[报告区]
是否出具试验/不确定度报告：是/否
报告编号：
 - 选“否”：自动填“/”并置灰
 - 选“是”：可编辑

[闭环关键勾选+附件]
是否包含拆装记录表： 是/否
 - 若是：上传【拆装记录表图片*】（必传）
是否包含试验过程记录表： 是/否
 - 若是：过程记录表清单组件（至少1条）
    [新增表名] [上传图片]
    列表：表名（下拉选择，读取TestProcessList;如果没有可填写并自动加入TestProcessList表） / 缩略图 / 替换 / 删除

[底部按钮]
[保存草稿]   [提交/完成]
```

提交时的错误提示建议：
- 在顶部给一个总提示：“无法提交：缺少过程记录表图片（至少 1 张）”
- 同时在对应区域字段下方红字标注

---

### 3.5 表单三：技术资料发放批准单（DocApproval）
草图：
```
标题：技术资料发放批准单（与主表 1对1）

名称：
编号：默认=主表合同编号（可改）
数量：
接收人：默认=任务提出人
发放人：默认=当前登录人
批准人：默认 admin（可下拉/输入）
发放日期：默认今天
文件地址(图片)*：上传控件（必传）

[底部按钮]
[保存草稿]   [提交/完成]
```

---

## 四、后端业务接口/服务建议（配合 UI 的最小集合）

### 4.1 资源获取策略（避免“必须先建 OneToOne”带来的空对象问题）
UI 点进表单时后端使用 `get_or_create`：
- `GET /main-record/{id}/test-info`：不存在就创建一个 DRAFT 返回
- `GET /main-record/{id}/doc-approval`：同上
- EntryExit：如果 `main.entry_exit_id` 为空，UI 先让用户“新建/选择已有”，再 `PATCH main.entry_exit_id=xxx`

### 4.2 “提交/撤回提交”统一模式
- `POST /test-info/{id}/submit`
- `POST /test-info/{id}/unsubmit`
（EntryExit、DocApproval 同理）

每个 submit 成功后：
- 写 `status=SUBMITTED, submitted_at=now()`
- 调用一次 `refresh_main_closed(main)`（以及 EntryExit 共享时，必要的话批量刷新所有引用它的 main_records——见下一条）

### 4.3 EntryExit 共享时的闭环刷新（别漏掉）
因为 EntryExit 的 `status` 影响多条 MainRecord：
- 当 EntryExit 提交/撤回时，应该刷新 **所有引用它的 MainRecord**：
  - `for main in entry_exit.main_records.all(): refresh_main_closed(main)`
  - 或者做一个批量更新（先查出符合闭环的 main_id 列表再 update），按你“速度优先”可后续再优化

---

补充：frontend\src\store\index.js中接口能获取username和fullname

需求：在backend\apps下新建app作为后端，在frontend\src\views\business下编写vue前端并使用pinia位置在frontend\src\store，在frontend\src\views\BusinessCenter.vue中添加界面入口并在frontend\src\components\layout\MainLayout.vue添加对应的标签；不用执行迁移完成代码即可有任何疑问可以问我